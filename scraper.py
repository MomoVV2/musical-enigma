import requests
from bs4 import BeautifulSoup
import os
import urllib.parse
from pathlib import Path
import time
import re
from http.server import HTTPServer, SimpleHTTPRequestHandler


class AcademyFiveScraper:
    def __init__(self, base_url, output_dir="scraped_site"):
        self.base_url = base_url
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Educational-Security-Demo/1.0'
        })

        # Color correction mapping
        self.color_corrections = {
            '#628da2': '#009ca6',
            'rgb(98,141,162)': 'rgb(0,156,166)',
            'rgb(98, 141, 162)': 'rgb(0, 156, 166)',
            'rgba(98,141,162': 'rgba(0,156,166',
            'rgba(98, 141, 162': 'rgba(0, 156, 166'
        }

    def create_color_override_css(self):
        """Create a targeted CSS file that fixes colors and missing elements"""
        override_css = """
    /* Targeted Color Override CSS - Fixes specific issues */
    /* Generated by Educational Demo Scraper */

    /* Only target elements that specifically use the wrong color #628da2 */
    [style*="#628da2"] {
        color: #009ca6 !important;
        background-color: #009ca6 !important;
        border-color: #009ca6 !important;
    }

    [style*="rgb(98,141,162)"] {
        color: rgb(0,156,166) !important;
        background-color: rgb(0,156,166) !important;
        border-color: rgb(0,156,166) !important;
    }

    [style*="rgb(98, 141, 162)"] {
        color: rgb(0, 156, 166) !important;
        background-color: rgb(0, 156, 166) !important;
        border-color: rgb(0, 156, 166) !important;
    }

    /* Fix "Profil" button - white text on teal background */
    .navbar .btn,
    .navbar .button,
    .navbar a,
    .nav .btn,
    .nav .button,
    .nav a,
    [style*="background-color: #009ca6"] a,
    [style*="background-color:#009ca6"] a,
    [style*="background: #009ca6"] a,
    [style*="background:#009ca6"] a {
        color: white !important;
    }

    /* Fix footer links - should be white */
    footer a,
    .footer a,
    [class*="footer"] a,
    [id*="footer"] a {
        color: white !important;
    }

    /* Footer background should stay teal */
    footer,
    .footer,
    [class*="footer"],
    [id*="footer"] {
        background-color: #009ca6 !important;
        color: white !important;
    }

    /* Fix any buttons with teal background to have white text */
    .btn[style*="#009ca6"],
    .button[style*="#009ca6"],
    button[style*="#009ca6"] {
        color: white !important;
    }

    /* Add missing arrow to "Anmelden" button */
    button[type="submit"]:after,
    .btn[class*="submit"]:after,
    [value*="Anmelden"]:after,
    [value*="anmelden"]:after {
        content: " â†’" !important;
        margin-left: 5px !important;
        font-weight: bold !important;
    }

    /* Add missing up arrow at bottom */
    body:after {
        content: "â†‘" !important;
        position: fixed !important;
        bottom: 20px !important;
        right: 20px !important;
        background-color: #009ca6 !important;
        color: white !important;
        width: 40px !important;
        height: 40px !important;
        border-radius: 50% !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        font-size: 20px !important;
        font-weight: bold !important;
        cursor: pointer !important;
        z-index: 9999 !important;
        box-shadow: 0 2px 10px rgba(0,0,0,0.2) !important;
    }

    /* Target specific CSS classes that might use the wrong color */
    .color-628da2,
    .bg-628da2,
    .border-628da2 {
        color: #009ca6 !important;
        background-color: #009ca6 !important;
        border-color: #009ca6 !important;
    }

    /* Fix any CSS custom properties */
    :root {
        --color-628da2: #009ca6 !important;
        --bg-628da2: #009ca6 !important;
        --primary-wrong: #009ca6 !important;
    }

    /* SVG path fixes for specific wrong color */
    svg path[fill="#628da2"],
    svg path[fill="rgb(98,141,162)"],
    svg path[fill="rgb(98, 141, 162)"] {
        fill: #009ca6 !important;
    }

    /* Ensure teal backgrounds have white text */
    [style*="background-color: #009ca6"],
    [style*="background-color:#009ca6"],
    [style*="background: #009ca6"],
    [style*="background:#009ca6"] {
        color: white !important;
    }

    /* Fix specific navigation elements */
    .navbar-nav a,
    .nav-link,
    .navbar-brand {
        color: white !important;
    }

    /* Make sure links in teal areas are visible */
    .bg-primary a,
    .navbar a,
    .nav a,
    .header a {
        color: white !important;
    }

    .bg-primary a:hover,
    .navbar a:hover,
    .nav a:hover,
    .header a:hover {
        color: #f0f0f0 !important;
    }
    """

        css_file_path = self.output_dir / "color-override.css"
        with open(css_file_path, 'w', encoding='utf-8') as f:
            f.write(override_css)

        print(f"ğŸ¨ Created enhanced color override CSS: {css_file_path}")
        return css_file_path

    def inject_color_override(self, soup):
        """Inject enhanced color override CSS into HTML"""
        # Create the override CSS file
        css_file_path = self.create_color_override_css()

        # Add link to override CSS in HTML head
        head = soup.find('head')
        if head:
            # Add our override CSS as the last stylesheet (highest priority)
            link_tag = soup.new_tag('link', rel='stylesheet', href='color-override.css', type='text/css')
            head.append(link_tag)

            # Add targeted inline styles for critical fixes
            style_tag = soup.new_tag('style', type='text/css')
            style_tag.string = """
    /* Critical inline overrides */
    [style*="#628da2"] { 
        color: #009ca6 !important; 
        background-color: #009ca6 !important; 
        border-color: #009ca6 !important; 
    }
    [style*="rgb(98,141,162)"] { 
        color: rgb(0,156,166) !important; 
        background-color: rgb(0,156,166) !important; 
        border-color: rgb(0,156,166) !important; 
    }
    /* Ensure text is visible on teal backgrounds */
    [style*="background-color: #009ca6"] * {
        color: white !important;
    }
    .navbar *, .nav *, footer *, .footer * {
        color: white !important;
    }
    """
            head.append(style_tag)

            print("ğŸ¨ Injected enhanced color override into HTML head")

        return soup

    def inject_color_override(self, soup):
        """Inject targeted color override CSS into HTML"""
        # Create the override CSS file
        css_file_path = self.create_color_override_css()

        # Add link to override CSS in HTML head
        head = soup.find('head')
        if head:
            # Add our override CSS as the last stylesheet (highest priority)
            link_tag = soup.new_tag('link', rel='stylesheet', href='color-override.css', type='text/css')
            head.append(link_tag)

            # Add only targeted inline styles
            style_tag = soup.new_tag('style', type='text/css')
            style_tag.string = """
    /* Targeted inline override - only for wrong colors */
    [style*="#628da2"] { 
        color: #009ca6 !important; 
        background-color: #009ca6 !important; 
        border-color: #009ca6 !important; 
    }
    [style*="rgb(98,141,162)"] { 
        color: rgb(0,156,166) !important; 
        background-color: rgb(0,156,166) !important; 
        border-color: rgb(0,156,166) !important; 
    }
    [style*="rgb(98, 141, 162)"] { 
        color: rgb(0, 156, 166) !important; 
        background-color: rgb(0, 156, 166) !important; 
        border-color: rgb(0, 156, 166) !important; 
    }
    """
            head.append(style_tag)

            print("ğŸ¨ Injected targeted color override into HTML head")

        return soup

    def inject_color_override(self, soup):
        """Inject color override CSS into HTML"""
        # Create the override CSS file
        css_file_path = self.create_color_override_css()

        # Add link to override CSS in HTML head
        head = soup.find('head')
        if head:
            # Add our override CSS as the last stylesheet (highest priority)
            link_tag = soup.new_tag('link', rel='stylesheet', href='color-override.css', type='text/css')
            head.append(link_tag)

            # Also add inline styles for extra override power
            style_tag = soup.new_tag('style', type='text/css')
            style_tag.string = """
/* Inline color override for maximum priority */
* { --brand-color: #009ca6 !important; }
.nav, .navbar, .navigation { background-color: #009ca6 !important; }
a, .link { color: #009ca6 !important; }
[style*="#628da2"] { color: #009ca6 !important; background-color: #009ca6 !important; }
"""
            head.append(style_tag)

            print("ğŸ¨ Injected color override into HTML head")

        return soup

    def download_external_css(self, soup):
        """Download CSS from external sources including Cloudflare"""
        external_css_found = []

        for link in soup.find_all('link', rel='stylesheet'):
            href = link.get('href')
            if not href:
                continue

            # Convert to absolute URL
            if href.startswith('//'):
                css_url = 'https:' + href
            elif href.startswith('/'):
                css_url = urllib.parse.urljoin(self.base_url, href)
            elif not href.startswith('http'):
                css_url = urllib.parse.urljoin(self.base_url, href)
            else:
                css_url = href

            # Download external CSS (including Cloudflare)
            try:
                print(f"ğŸ“¥ Downloading external CSS: {css_url}")
                response = self.session.get(css_url, timeout=10)
                response.raise_for_status()

                # Fix colors in the CSS content
                css_content = self.fix_colors_in_text(response.content)

                # Create local filename
                parsed_url = urllib.parse.urlparse(css_url)
                filename = parsed_url.path.split('/')[-1] or 'external.css'
                if not filename.endswith('.css'):
                    filename += '.css'

                local_css_path = self.output_dir / f"external-{filename}"

                # Save the fixed CSS
                with open(local_css_path, 'w', encoding='utf-8') as f:
                    f.write(css_content)

                # Update the link to point to local file
                link['href'] = local_css_path.name
                external_css_found.append(css_url)

                print(f"âœ… Downloaded and fixed: {local_css_path.name}")

            except Exception as e:
                print(f"âš ï¸  Failed to download {css_url}: {e}")

        return external_css_found

    def fix_colors_in_text(self, content):
        """Fix color values in text content (CSS, HTML, etc.)"""
        if isinstance(content, bytes):
            content = content.decode('utf-8', errors='ignore')

        for wrong_color, correct_color in self.color_corrections.items():
            # Case insensitive replacement
            content = re.sub(re.escape(wrong_color), correct_color, content, flags=re.IGNORECASE)

        return content

    def scrape_page(self, url, save_path):
        """Scrape a single page and save it"""
        try:
            print(f"Scraping: {url}")
            time.sleep(0.5)
            response = self.session.get(url)
            response.raise_for_status()

            soup = BeautifulSoup(response.content, 'html.parser')

            # Download external CSS (including Cloudflare) FIRST
            external_css = self.download_external_css(soup)

            # Download other assets
            self.download_assets(soup, 'script', 'src', '.js')
            self.download_assets(soup, 'img', 'src', ['.png', '.jpg', '.jpeg', '.gif', '.svg'])

            # Fix colors in HTML
            soup = self.fix_colors_in_html(soup)

            # Inject our color override CSS
            soup = self.inject_color_override(soup)

            # Save HTML
            with open(save_path, 'w', encoding='utf-8') as f:
                f.write(str(soup))

            print(f"âœ… Saved: {save_path}")
            if external_css:
                print(f"ğŸ“¥ Downloaded {len(external_css)} external CSS file(s)")

            return soup

        except Exception as e:
            print(f"âŒ Error scraping {url}: {e}")
            return None

    def download_assets(self, soup, tag, attr, extensions):
        """Download JS and image assets (CSS handled separately)"""
        for element in soup.find_all(tag):
            asset_url = element.get(attr)
            if not asset_url:
                continue

            # Handle relative URLs
            if asset_url.startswith('//'):
                asset_url = 'https:' + asset_url
            elif asset_url.startswith('/'):
                asset_url = urllib.parse.urljoin(self.base_url, asset_url)
            elif not asset_url.startswith('http'):
                asset_url = urllib.parse.urljoin(self.base_url, asset_url)

            # Check file extension
            if isinstance(extensions, list):
                if not any(asset_url.lower().endswith(ext) for ext in extensions):
                    continue
            else:
                if not asset_url.lower().endswith(extensions):
                    continue

            self.download_asset(asset_url, element, attr)

    def download_asset(self, url, element, attr):
        """Download individual asset"""
        try:
            response = self.session.get(url, timeout=10)
            response.raise_for_status()

            # Create local path
            parsed_url = urllib.parse.urlparse(url)
            local_path = self.output_dir / parsed_url.path.lstrip('/')
            local_path.parent.mkdir(parents=True, exist_ok=True)

            # Save file
            with open(local_path, 'wb') as f:
                f.write(response.content)

            # Update element to point to local file
            element[attr] = str(local_path.relative_to(self.output_dir))

        except Exception as e:
            print(f"âš ï¸  Failed to download {url}: {e}")

    def fix_colors_in_html(self, soup):
        """Fix colors in HTML content"""
        changes_made = False

        # Fix inline styles
        elements_with_style = soup.find_all(attrs={'style': True})
        for element in elements_with_style:
            original_style = element['style']
            fixed_style = self.fix_colors_in_text(original_style)
            if fixed_style != original_style:
                element['style'] = fixed_style
                changes_made = True

        # Fix style tags
        style_tags = soup.find_all('style')
        for style_tag in style_tags:
            if style_tag.string:
                original_css = style_tag.string
                fixed_css = self.fix_colors_in_text(original_css)
                if fixed_css != original_css:
                    style_tag.string = fixed_css
                    changes_made = True

        if changes_made:
            print("ğŸ¨ Fixed colors in HTML content")

        return soup

    def analyze_page_structure(self, soup):
        """Analyze page structure for demo"""
        print("\nğŸ“Š Page Structure Analysis:")
        print("=" * 30)

        # Count elements
        forms = len(soup.find_all('form'))
        inputs = len(soup.find_all('input'))
        links = len(soup.find_all('a'))
        scripts = len(soup.find_all('script'))
        css_links = len(soup.find_all('link', rel='stylesheet'))

        print(f"Forms: {forms}")
        print(f"Input fields: {inputs}")
        print(f"Links: {links}")
        print(f"Script tags: {scripts}")
        print(f"CSS files: {css_links}")

        # Check for common frameworks
        page_text = str(soup).lower()
        frameworks = []
        if 'jquery' in page_text:
            frameworks.append("jQuery")
        if 'bootstrap' in page_text:
            frameworks.append("Bootstrap")
        if 'vue' in page_text:
            frameworks.append("Vue.js")
        if 'react' in page_text:
            frameworks.append("React")
        if 'angular' in page_text:
            frameworks.append("Angular")
        if 'cloudflare' in page_text:
            frameworks.append("Cloudflare")

        if frameworks:
            print(f"ğŸ“š Technologies detected: {', '.join(frameworks)}")

    def analyze_security(self, soup):
        """Analyze for security demo"""
        self.analyze_page_structure(soup)

        print("\nğŸ” Security Analysis:")
        print("=" * 30)

        forms = soup.find_all('form')
        if not forms:
            print("â„¹ï¸  No forms found on this page")

            # Check for potential AJAX login
            scripts = soup.find_all('script')
            for script in scripts:
                if script.string and any(word in script.string.lower() for word in ['login', 'auth', 'signin']):
                    print("âš ï¸  Potential AJAX login detected in JavaScript")
                    break
            return

        for i, form in enumerate(forms):
            print(f"\nForm {i + 1}:")
            action = form.get('action', 'No action')
            method = form.get('method', 'GET').upper()

            print(f"  Action: {action}")
            print(f"  Method: {method}")

            # Security checks
            if method == 'GET':
                print("  âš ï¸  WARNING: Using GET for form submission")

            if action and not action.startswith('https://') and not action.startswith('/'):
                print("  âš ï¸  WARNING: Form action may not be secure")

            # Analyze inputs
            inputs = form.find_all('input')
            password_fields = 0

            for inp in inputs:
                name = inp.get('name', 'unnamed')
                input_type = inp.get('type', 'text')
                autocomplete = inp.get('autocomplete', 'not set')
                required = 'required' in inp.attrs

                print(f"    Input: {name} ({input_type}) - autocomplete: {autocomplete}, required: {required}")

                if input_type == 'password':
                    password_fields += 1
                    if autocomplete != 'off':
                        print("      âš ï¸  Password field allows autocomplete")

            if password_fields > 0:
                print(f"  ğŸ”‘ Login form detected ({password_fields} password field(s))")

        # Check for CSRF protection
        csrf_tokens = soup.find_all('input', {'name': lambda x: x and 'csrf' in x.lower()})
        if not csrf_tokens:
            print("\nâš ï¸  No CSRF tokens detected")
        else:
            print(f"\nâœ… CSRF protection found ({len(csrf_tokens)} token(s))")


class DemoServer(SimpleHTTPRequestHandler):
    def end_headers(self):
        self.send_header('Access-Control-Allow-Origin', '*')
        self.send_header('Cache-Control', 'no-cache')
        super().end_headers()

    def log_message(self, format, *args):
        # Suppress default logging
        pass


def serve_demo(port=8000):
    """Start local demo server"""
    if os.path.exists('scraped_site'):
        original_dir = os.getcwd()
        os.chdir('scraped_site')
        server = HTTPServer(('localhost', port), DemoServer)
        print(f"ğŸŒ Demo running at: http://localhost:{port}")
        print("ğŸ“ Files available:")
        for file in Path('.').glob('*.html'):
            print(f"   http://localhost:{port}/{file}")
        print("\nPress Ctrl+C to stop")
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            print("\nğŸ‘‹ Server stopped")
            os.chdir(original_dir)
    else:
        print("âŒ No scraped_site folder found. Run scraper first!")